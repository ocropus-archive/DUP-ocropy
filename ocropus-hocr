#!/usr/bin/env python

import __builtin__ as python
import random as pyrandom
import sys
import os.path
import re
import glob
import argparse
import codecs
import unicodedata
import numpy as np
from matplotlib.pyplot import imread
#from unicodedata import name
import ocrolib
from ocrolib import hocr

parser = argparse.ArgumentParser("""
Construct an HTML output file in hOCR format by putting together
the recognition results for each page in sequence.
You should usually invoke this program as 

    ocropus-hocr 'book/????.bin.png'

For each page like 'book/0001.bin.png', it uses the following files:

    book/0001.bin.png            # page image
    book/0001.pseg.png           # page segmentation
    book/0001/010001.txt         # recognizer output for lines
""")
parser.add_argument("-b","--nobreaks",action="store_true",help="don't output line breaks")
parser.add_argument("-p","--nopars",action="store_true",help="don't output paragraphs")
parser.add_argument("-s","--fscale",type=float,default=1.0,help="scale factor for translating xheights into font size (use 0 to disable), default: %(default)s")
parser.add_argument("-o","--output",default="book.html",help="output file, default: %(default)s")
parser.add_argument("-w","--ocrwords",action="store_true",help="output ocr_word spans in hocr")
parser.add_argument('files',nargs='+')
args = parser.parse_args()
args.files = ocrolib.glob_all(args.files)

ostream = codecs.open(args.output,"w","utf-8")

def E(*args):
    args = [str(x) for x in args]
    sys.stderr.write(" ".join(args))
    sys.stderr.write("\n")
def P(*args):
    ostream.write("".join(args)+"\n")
def PN(*args):
    ostream.write("".join(args))

E("writing to",args.output)
median_xheight = None
dirs = [ocrolib.allsplitext(name)[0] for name in args.files]
xhfiles = python.sum([glob.glob(d+"/??????.xheight") for d in dirs],[])
if len(xhfiles)>5:
    xheights = [float(ocrolib.read_text(f)) for f in xhfiles]
    if len(xheights)>0:
        median_xheight = np.median(xheights)
else:    
    lfiles = python.sum([glob.glob(d+"/??????.bin.png") for d in dirs],[])
    pyrandom.shuffle(lfiles)
    if len(lfiles)>0:
        median_xheight = 0.5*np.median([imread(f).shape[0] for f in lfiles[:100]])
E("median_xheight",median_xheight)

P(hocr.header())

last_coords = None

for arg in args.files:
    base,_ = ocrolib.allsplitext(arg)
    try:
        E("===",arg)
        image = ocrolib.read_image_binary(arg)
        height, width = image.shape
        P("<div class='ocr_page' title='image %s; bbox 0 0 %d %d'>"%(arg,width,height))

        # to proceed, we need a pseg file and a
        # subdirectory containing text lines

        if not os.path.exists(base+".pseg.png"):
            E("%s: no such file"%(base+".pseg.png",))
            continue

        if not os.path.isdir(base):
            E("%s: no such directory"%base)
            continue

        # iterate through the text lines in reading order, based
        # on the page segmentation file

        pseg = ocrolib.read_page_segmentation(base+".pseg.png")
        regions = ocrolib.RegionExtractor()
        regions.setPageLines(pseg)
        for i in range(1,regions.length()):

            # keep track of the bounding box information for each line
            # and insert paragraph breaks as needed

            id = regions.id(i)
            y0,x0,y1,x1 = regions.bbox(i)
            if last_coords is not None:
                lx0,ly0 = last_coords
                dx,dy = x0-lx0,y1-ly0
                par = 0
                if dy>0: 
                    par = 0 # column break... moving upwards
                else:
                    if median_xheight is not None:
                        if abs(dy)>5*median_xheight: par = 1 # whitespace separator
                        if dx>2*median_xheight: par = 1 # indented paragraph
                        if abs(dx)>10*median_xheight: par = 1 # something else
                if par and not args.nopars: P("<p />")
            last_coords = (x0,y0)

            # get the text for the line itself

            lbase = "%s/%06x"%(base,id)

            if not os.path.exists(lbase+".txt"):
                E("note: line %s produced no output (it may not have contained text)"%(lbase+".bin.png"))
                continue

            text = ocrolib.read_text(lbase+".txt")

            text = re.sub(r'\&','\&amp;',text)
            text = re.sub(r'\<','\&lt;',text)

            # accumulate character position information for each line if the 
            # user wants <span char="ocr_word"> and if the llocs files are available
            # (these are output by setting the --llocs switch on ocropus-rpred) 
            if (args.ocrwords and os.path.exists(lbase+".llocs")):
                char_pos_data =  codecs.open(lbase+".llocs",'r','utf-8').read()
                lines = char_pos_data.split("\n")
                char_coords = []
                for line in lines:
                    elements = line.split("\t")
                    #sometimes a line is blank, providing no info. We skip these
                    if (len(elements) == 2):
                        to_coords = [elements[0],int(float(elements[1]))]
                        if not (elements[0] == ''):
                            char_coords.append(to_coords)
                # remove final and initial spaces in lines, since they do not signify and they
                # mess up word bboxes
                if (char_coords[-1][0] == u" "):
                    char_coords = char_coords[:-1]
                if (char_coords[0][0] == u" "):
                    char_coords = char_coords[1:]
                    #it seems rpred messes up when this happens, and gives the coord of the first real
                    #(non-space) character. So we need to bump them up
                    #print "we be spacing!"
                    #print "in"
                    #print char_coords
                    #b=[row[0] for row in char_coords]
                    #c=[row[1] for row in char_coords]
                    #b=b[1:]
                    #c=c[:-1]
                    #out = []
                    #for x, y in zip(b, c):
                       #out = out + [[x,y]]
                    #char_coords=out
                    #print "out"
                    #print char_coords
                for char_coord in char_coords:
                    print    char_coord[0] + " " + unicodedata.name(char_coord[0][0]) + " " + str(char_coord[1])
                    #print "'", name(char_cood[0])
            style = ""
            info = ""

            # estimate the font size for this line

            if median_xheight is not None and os.path.exists(lbase+".xheight"):
                xheight = float(ocrolib.read_text(lbase+".xheight"))
                perc = int(np.clip(xheight*100.0/median_xheight,30,300))
                perc = 10*((perc+5)//10)
                if perc!=100:
                    style += "font-size:%d%%;"%perc

            # output geometric information 

            info += "bbox %d %d %d %d"%(x0,y0,x1,y1)
            if os.path.exists(lbase+".baseline"):
                info += "; baseline "+ocrolib.read_text(lbase+".baseline")

            # put it all together into a SPAN

            PN("<span")
            if style!="": PN(" style='"+style+"'")
            # use the data from the llocs files to provide <span class="ocr_word"> elements and their
            # content if the user so desires and if the collected data is not empty. For instance,
            # if the line only contained a space character, it would be striped and the list would
            # be empty
            if args.ocrwords and (len(char_coords) > 0):
		    try:
			PN(" class='ocr_line' title='%s'>"%info)
			# loop through all the characters in the line, breaking to make a new ocr_word
			# when we come to a space
                        # use the line coordinates to seed the word coordinates. In particular the y values
                        # are always used for word bounding boxes
			word_x0 = x0
			word_y0 = y0
			word_x1 = x0
			word_y1 = y1
			current_word = u""
                        # the last element is a special case, so we run a counter to be able to detect it
			char_coords_count = len(char_coords)
			count = 0 
                        # keep track of the last char's x in order to put the word x boundary in the middle of the 
                        # space between words. This ensures that no part of the word gets omitted from the bbox
                        previous_char_x = 0
                        previous_char = u""
			for char_coord in char_coords:
			    current_char, char_x = char_coord
                            if (current_char == u" "):
                                midpoint = (char_x + previous_char_x) / 2
				word_x1 = char_x + x0
				word_info="bbox %d %d %d %d"%(word_x0,word_y0,word_x1,word_y1)
				PN("<span class='ocr_word' title='%s'>"%word_info,current_word,"</span> ")
				# set the beginning x of the next word to the ending x of this one
                                word_x0 = word_x1
                                # reset the accumulated characters in the word
				current_word = u""
                            elif (count == (char_coords_count-1)):
                                # in the case of the last character in the line:
                                # 1) the *line's* greatest x value is used as this element's, too
                                word_info="bbox %d %d %d %d"%(word_x0,word_y0,x1,word_y1)
                                # 2) no space is put after the word span
                                PN("<span class='ocr_word' title='%s'>"%word_info,current_word+current_char,"</span>")
			    else:
                                # if the current character is not a space, then append it to current word
                                # which will be outputted in the <span class="ocr_word" when a space *is*
                                # encountered
				current_word = current_word + current_char
			    count = count + 1
                            previous_char_x = char_x
                            previous_char = current_char
			PN("</span>")
		    except:
			E("Data for ocr_word elements is not available. Did you select --llocs in ocropus-rpred?")
			PN(" class='ocr_line' title='%s'>"%info,text,"</span>")
            else:
                 PN(" class='ocr_line' title='%s'>"%info,text,"</span>")
            if not args.nobreaks: P("<br />")
            else: P()

    finally:
        P("</div>")

P(hocr.footer())

ostream.close()
