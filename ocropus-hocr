#!/usr/bin/env python

import __builtin__ as python
import random as pyrandom
import sys
import os.path
import re
import glob
import argparse
import codecs

import numpy as np
from matplotlib.pyplot import imread

import ocrolib
from ocrolib import hocr

parser = argparse.ArgumentParser("""
Construct an HTML output file in hOCR format by putting together
the recognition results for each page in sequence.
You should usually invoke this program as 

    ocropus-hocr 'book/????.bin.png'

For each page like 'book/0001.bin.png', it uses the following files:

    book/0001.bin.png            # page image
    book/0001.pseg.png           # page segmentation
    book/0001/010001.txt         # recognizer output for lines
""")
parser.add_argument("-b","--nobreaks",action="store_true",help="don't output line breaks")
parser.add_argument("-p","--nopars",action="store_true",help="don't output paragraphs")
parser.add_argument("-s","--fscale",type=float,default=1.0,help="scale factor for translating xheights into font size (use 0 to disable), default: %(default)s")
parser.add_argument("-o","--output",default="book.html",help="output file, default: %(default)s")
parser.add_argument("-w","--ocrwords",action="store_true",help="output ocr_word spans in hocr")
parser.add_argument('files',nargs='+')
args = parser.parse_args()
args.files = ocrolib.glob_all(args.files)

ostream = codecs.open(args.output,"w","utf-8")

def E(*args):
    args = [str(x) for x in args]
    sys.stderr.write(" ".join(args))
    sys.stderr.write("\n")
def P(*args):
    ostream.write("".join(args)+"\n")
def PN(*args):
    ostream.write("".join(args))

E("writing to",args.output)
median_xheight = None
dirs = [ocrolib.allsplitext(name)[0] for name in args.files]
xhfiles = python.sum([glob.glob(d+"/??????.xheight") for d in dirs],[])
if len(xhfiles)>5:
    xheights = [float(ocrolib.read_text(f)) for f in xhfiles]
    if len(xheights)>0:
        median_xheight = np.median(xheights)
else:    
    lfiles = python.sum([glob.glob(d+"/??????.bin.png") for d in dirs],[])
    pyrandom.shuffle(lfiles)
    if len(lfiles)>0:
        median_xheight = 0.5*np.median([imread(f).shape[0] for f in lfiles[:100]])
E("median_xheight",median_xheight)

P(hocr.header())

last_coords = None

for arg in args.files:
    base,_ = ocrolib.allsplitext(arg)
    try:
        E("===",arg)
        image = ocrolib.read_image_binary(arg)
        height, width = image.shape
        P("<div class='ocr_page' title='image %s; bbox 0 0 %d %d'>"%(arg,width,height))

        # to proceed, we need a pseg file and a
        # subdirectory containing text lines

        if not os.path.exists(base+".pseg.png"):
            E("%s: no such file"%(base+".pseg.png",))
            continue

        if not os.path.isdir(base):
            E("%s: no such directory"%base)
            continue

        # iterate through the text lines in reading order, based
        # on the page segmentation file

        pseg = ocrolib.read_page_segmentation(base+".pseg.png")
        regions = ocrolib.RegionExtractor()
        regions.setPageLines(pseg)
        for i in range(1,regions.length()):

            # keep track of the bounding box information for each line
            # and insert paragraph breaks as needed

            id = regions.id(i)
            y0,x0,y1,x1 = regions.bbox(i)
            if last_coords is not None:
                lx0,ly0 = last_coords
                dx,dy = x0-lx0,y1-ly0
                par = 0
                if dy>0: 
                    par = 0 # column break... moving upwards
                else:
                    if median_xheight is not None:
                        if abs(dy)>5*median_xheight: par = 1 # whitespace separator
                        if dx>2*median_xheight: par = 1 # indented paragraph
                        if abs(dx)>10*median_xheight: par = 1 # something else
                if par and not args.nopars: P("<p />")
            last_coords = (x0,y0)

            # get the text for the line itself

            lbase = "%s/%06x"%(base,id)

            if not os.path.exists(lbase+".txt"):
                E("note: line %s produced no output (it may not have contained text)"%(lbase+".bin.png"))
                continue

            text = ocrolib.read_text(lbase+".txt")

            text = re.sub(r'\&','\&amp;',text)
            text = re.sub(r'\<','\&lt;',text)

            # accumulate character position information for each line if the 
            # user wants <span char="ocr_word"> and if the llocs files are available
            # (these are output by setting the --llocs switch on ocropus-gpageseg) 
            if (args.ocrwords and os.path.exists(lbase+".llocs")):
                char_pos_data =  codecs.open(lbase+".llocs",'r','utf-8').read()
                lines = char_pos_data.split("\n")
                #the last line is blank, providing no info
                lines = lines[:-1]
                char_coords = []
                for line in lines:
                    elements = line.split("\t")
                    to_coords = [elements[0],int(float(elements[1]))]
                    if not (elements[0] == ''):
                        char_coords.append(to_coords)
                # remove final and initial spaces in lines, since they do not signify and they
                # mess up word bboxes
                if (char_coords[-1][0] == u" "):
                    char_coords = char_coords[:-1]
                if (char_coords[0][0] == u" "):
                    char_coords = char_coords[1:]
            style = ""
            info = ""

            # estimate the font size for this line

            if median_xheight is not None and os.path.exists(lbase+".xheight"):
                xheight = float(ocrolib.read_text(lbase+".xheight"))
                perc = int(np.clip(xheight*100.0/median_xheight,30,300))
                perc = 10*((perc+5)//10)
                if perc!=100:
                    style += "font-size:%d%%;"%perc

            # output geometric information 

            info += "bbox %d %d %d %d"%(x0,y0,x1,y1)
            if os.path.exists(lbase+".baseline"):
                info += "; baseline "+ocrolib.read_text(lbase+".baseline")

            # put it all together into a SPAN

            PN("<span")
            if style!="": PN(" style='"+style+"'")
            # use the data from the llocs files to provide <span class="ocr_word"> elements and their
            # content if the user so desires and if the collected data is not empty. For instance,
            # if the line only contained a space character, it would be striped and the list would
            # be empty
            if args.ocrwords and (len(char_coords) > 0):
		    try:
			PN(" class='ocr_line' title='%s'>"%info)
			# loop through all the characters in the line, breaking to make a new ocr_word
			# when we come to a space
                        # use the line coordinates to seed the word coordinates. In particular the y values
                        # are always used for word bounding boxes
			word_x0 = x0
			word_y0 = y0
			word_x1 = x0
			word_y1 = y1
			current_word = u""
                        # the last element is a special case, so we run a counter to be able to detect it
			char_coords_count = len(char_coords)
			count = 0 
                        # keep track of the last char's x in order to put the word x boundary in the middle of the 
                        # space between words. This ensures that no part of the word gets omitted from the bbox
                        previous_char_x = 0
			for char_coord in char_coords:
			    current_char, char_x = char_coord
			    if (current_char == u" "):
                                midpoint = (char_x + previous_char_x) / 2
				word_x1 = midpoint + x0
				word_info="bbox %d %d %d %d"%(word_x0,word_y0,word_x1,word_y1)
				PN("<span class='ocr_word' title='%s'>"%word_info,current_word,"</span> ")
				# set the beginning x of the next word to the ending x of this one
                                word_x0 = word_x1
                                # reset the accumulated characters in the word
				current_word = u""
                            elif (count == (char_coords_count-1)):
                                # in the case of the last character in the line:
                                # 1) the *line's* greatest x value is used as this element's, too
                                word_info="bbox %d %d %d %d"%(word_x0,word_y0,x1,word_y1)
                                # 2) no space is put after the word span
                                PN("<span class='ocr_word' title='%s'>"%word_info,current_word,"</span>")
			    else:
                                # if the current character is not a space, then append it to current word
                                # which will be outputted in the <span class="ocr_word" when a space *is*
                                # encountered
				current_word = current_word + current_char
			    count = count + 1
                            previous_char_x = char_x
			PN("</span>")
		    except:
			E("Data for ocr_word elements is not available. Did you select --llocs in ocropus-gpageseg?")
			PN(" class='ocr_line' title='%s'>"%info,text,"</span>")
            else:
                 PN(" class='ocr_line' title='%s'>"%info,text,"</span>")
            if not args.nobreaks: P("<br />")
            else: P()

    finally:
        P("</div>")

P(hocr.footer())

ostream.close()
