#!/usr/bin/python

# make the clustering class-specific

import sys,os,re,glob,math,glob,signal,traceback
import matplotlib
matplotlib.use("AGG")
from scipy.ndimage import interpolation
from pylab import *
from optparse import OptionParser
from multiprocessing import Pool
import ocrolib
from ocrolib import number_of_processors,die

signal.signal(signal.SIGINT,lambda *args:sys.exit(1))

parser = OptionParser("""
usage: %prog [options] [text.txt langmod.fst image.png ...]

""")

# these options control alignment
parser.add_option("-m","--model",help="model file",default="unlv.model")
parser.add_option("-s","--segmenter",help="segmenter",default="DpSegmenter")
parser.add_option("-S","--suffix",help="suffix for writing rseg/cseg files",default=None)
parser.add_option("-O","--overwrite",help="overwrite rseg/cseg files",action="store_true")
parser.add_option("-Q","--parallel",type=int,default=0,help="number of parallel processes to use")
(options,args) = parser.parse_args()

if len(args)==0:
    parser.print_help()
    sys.exit(0)

cmodel = ocrolib.load_component(ocrolib.ocropus_find_file(options.model))
assert cmodel is not None
linerec = ocrolib.CmodelLineRecognizer(cmodel=cmodel)

def extract(t):
    fname = t
    image = ocrolib.read_image_gray(fname)
    lattice,rseg = linerec.recognizeLineSeg(image)

    lattice_file = ocrolib.fvariant(fname,"fst",options.suffix)
    if os.path.exists(lattice_file) and not options.overwrite:
        die("%s: %s",lattice_file,"already exists")
    lattice.save(lattice_file)

    rseg_file = ocrolib.fvariant(fname,"rseg",options.suffix)
    if os.path.exists(rseg_file) and not options.overwrite:
        die(rseg_file,"already exists")
    ocrolib.write_line_segmentation(rseg_file,rseg)

    s = lattice.bestpath()
    print fname,":",s

if options.parallel<2:
    for arg in args: extract(arg)
else:
    pool = Pool(processes=options.parallel)
    result = pool.map(extract,args)
