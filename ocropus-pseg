#!/usr/bin/python

import signal
signal.signal(signal.SIGINT,lambda *args:sys.exit(1))
import sys,os,re,optparse,shutil
from matplotlib import patches
from pylab import *
from scipy.stats.stats import trim1

from scipy.ndimage import measurements
from scipy.misc import imsave
from PIL import Image
import ocropy
from ocropy import N,NI

parser = optparse.OptionParser(usage="""
%prog [options] image1.png image2.png ...

Usually, you would use an argument pattern like: book/????/??????.png

Computes page segmentations and extracts text lines.
For each input image image.png, it generates:

* image.pseg.png -- page segmentation
* image/010001.png -- gray scale text line image column 1, line 1
* image/010001.bin.png -- bineary text line image column 1, line 1

Use the -d or -D argument to verify that the layout analysis is working
correctly.

If image.bin.png exists, it uses it.  If not, it uses built-in
preprocessing and generates and writes its own binary version.
(The original gray scale image is, however, not altered, so it
may be rotated relative to the binary image.)
""")
parser.add_option("-g","--gray",action="store_true",
                  help="output grayscale images + binary masks")
parser.add_option("-p","--pad",default=1,type=int,
                  help="pad lines by this amount")
parser.add_option("-d","--display",action="store_true",
                  help="display result")
parser.add_option("-D","--Display",action="store_true",
                  help="display continuously")
parser.add_option("-S","--segmenter",default="SegmentPageByRAST",
                  help="which segmentation component to use")
parser.add_option("-P","--preproc",default="StandardPreprocessing",
                  help="which preprocessing component to use")
parser.add_option("-r","--dpi",default=300,type=int,
                  help="resolution of input image in DPI")
options,args = parser.parse_args()


preproc = ocropy.make_IBinarize(options.preproc)
segmenter = ocropy.make_ISegmentPage(options.segmenter)

if options.Display: options.display = 1
if options.display: ion()

for arg in args:
    print
    print "===",arg,"==="
    print
    base,_ = ocropy.allsplitext(arg)
    image = ocropy.bytearray()
    ocropy.read_image_gray(image,arg)
    w,h = [image.dim(i) for i in [0,1]]

    # get a binary image, either saved on disk or through
    # preprocessing
    page_bin = ocropy.bytearray()
    if os.path.exists(base+".bin.png"):
        print "# loading",base+".bin.png"
        page_gray = image
        ocropy.read_image_gray(page_bin,base+".bin.png")
    else:
        print "# binarizing"
        page_gray = ocropy.bytearray()
        preproc.binarize(page_bin,page_gray,image)
        ocropy.write_image_gray(base+".bin.png",page_bin)

    # get a text/image segmentation if available
    page_ti = ocropy.intarray()
    if os.path.exists(base+".ti.png"):
        print "# loading",base+".ti.png"
        ocropy.read_image_packed(page_ti,base+".ti.png")
    else:
        page_ti.resize(w,h)
        page_ti.fill(0)

    # FIXME remove images here

    print "# segmenting"
    page_seg = ocropy.intarray()
    segmenter.segment(page_seg,page_bin)
    regions = ocropy.RegionExtractor()
    regions.setPageLines(page_seg)
    if os.path.exists(base):
        print "# removing",base
        shutil.rmtree(base)
    os.mkdir(base)

    print "# writing",regions.length(),"lines"
    if options.display:
        clf()
        axis = subplot(111)
        axis.imshow(NI(page_bin),cmap=cm.gray)

    line = ocropy.bytearray()
    for i in range(1,regions.length()):
        if options.display:
            x0 = regions.x0(i)
            y0 = regions.y0(i)
            x1 = regions.x1(i)
            y1 = regions.y1(i)
            p = patches.Rectangle((x0,h-y1-1),x1-x0,y1-y0,edgecolor="red",fill=0)
            axis.add_patch(p)
        if options.gray:
            regions.extract(line,page_gray,i,options.pad)
            ocropy.write_image_gray("%s/%06x.png"%(base,regions.id(i)),line)
            regions.extract_masked(line,page_bin,i,0,255,options.pad)
            # same as inverse of regions.mask(line,i,0)
            ocropy.write_image_gray("%s/%06x.bin.png"%(base,regions.id(i)),line)
        else:
            regions.extract_masked(line,page_bin,i,0,255,options.pad)
            ocropy.write_image_gray("%s/%06x.png"%(base,regions.id(i)),line)
    try:
        ocropy.make_page_segmentation_white(page_seg)
        ocropy.write_image_packed(base+".pseg.png",page_seg)
    except:
        print "# OOPS bad page segmentation?"
        ocropy.write_image_packed(base+".BAD-pseg.png",page_seg)
    if options.display:
        draw()
        if not options.Display: 
            raw_input("hit ENTER to continue")
        else:
            ginput(1,timeout=1)
